# x86 アセンブリ

https://tryhackme.com/room/x86assemblycrashcourse

## 基本

### オペランドの種類

- 即値 0x5f
- レジスタ eax
- メモリオペランド [eax]

### 引数とレジスタ（64ビット）

| 引数の番号 | 使用されるレジスタ | 備考                          |
|------------|---------------------|-------------------------------|
| 第1引数     | RDI                | 例: system("/bin/sh") の "/bin/sh" |
| 第2引数     | RSI                |                               |
| 第3引数     | RDX                |                               |
| 第4引数     | RCX                |                               |
| 第5引数     | R8                 |                               |
| 第6引数     | R9                 |                               |
| 7個目以降   | スタックにプッシュ     | RBPより高位に積まれる             |


### その他

h は、hex の意。

```
mov eax,10h
```

## 一般命令

### MOV（値を移動）

```
mov destination, source

mov eax, 0x5f
mov ebx, eax
mov eax, [0x5fc53e]
```

メモリーからメモリーへの MOV は不可。

### LEA（実効アドレスのロード）

オペランドには必ず角括弧が付く。  
算術結果をダイレクトにレジスタに代入したい場合によく使われる。

```
lea destination, source

lea eax, [ebp+4]
```

### NOP（何もしない）

マルウェア作成者がシェルコードへの実行をリダイレクトする際に使用される。実行がリダイレクトされる正確な場所は不明な場合が多いため、マルウェア作成者はシェルコードの実行が途中から開始されないように、多数の nop 命令を使用する。

```
nop
```

### SHIFT

ビットシフトした結果、1 があふれたらキャリーフラグ CF が 1 になる。

```
# right shift
shr destination, count

# left shift
shl destination, count
```

### ROTATE

左からあふれたビットが、右側に入ってくる

```
ror destination, count
rol destination, count
```

## 算術命令

### 加算、減算

```
add destination, value

sub destination, value
```

### 乗算、除算

乗算命令は、eax を乗算し、結果を 64 ビット値として edx:eax に格納する。

除算命令の場合は逆で、edx:eax 内の 64 ビット値を除算し、結果を eax に、余りを edx に格納する。

```
mul value

div value
```

### インクリメント、デクリメント

add, sub と異なり、CF を更新しない点は注意。

```
inc eax

dec eax
```

## 論理命令

### AND、OR、NOT、XOR

ビット単位の論理演算を実行

```
and al, 0x7c

or al, 0x7c

not al

xor al, 0x7c
```

## 条件文、分岐

### TEST、CMP

test 命令は、AND 演算を実行し、結果が 0 であれば、ゼロフラグ（ZF）を設定する。  
自身と比較することでオペランドの NULL チェックをするためによく使われる。

cmp 命令は sub 命令とほぼ同様に動作するが、オペランドは変更されず、ZF または CF が設定されるかに注目する。  
等しい場合は ZF、source の方が大きい場合は CF がセットされる。

```
test destination, source

cmp destination, source
```

### JUMP、条件 JUMP

```
jmp location
```

| 命令  | 説明                                                           |
| ----- | -------------------------------------------------------------- |
| `jz`  | ZF（ゼロフラグ）がセットされている場合にジャンプ（ZF = 1）     |
| `jnz` | ZF（ゼロフラグ）がセットされていない場合にジャンプ（ZF = 0）   |
| `je`  | 等しい場合にジャンプ。通常は `cmp` 命令の後に使われる          |
| `jne` | 等しくない場合にジャンプ。通常は `cmp` 命令の後に使われる      |
| `jg`  | 符号付き比較で、宛先オペランドがソースより大きい場合にジャンプ |
| `jl`  | 符号付き比較で、宛先オペランドがソースより小さい場合にジャンプ |
| `jge` | 符号付き比較で、宛先オペランドがソース以上の場合にジャンプ     |
| `jle` | 符号付き比較で、宛先オペランドがソース以下の場合にジャンプ     |
| `ja`  | 符号なし比較で、宛先オペランドがソースより大きい場合にジャンプ |
| `jb`  | 符号なし比較で、宛先オペランドがソースより小さい場合にジャンプ |
| `jae` | 符号なし比較で、宛先オペランドがソース以上の場合にジャンプ     |
| `jbe` | 符号なし比較で、宛先オペランドがソース以下の場合にジャンプ     |

## スタック命令

### PUSH

オペランドの値はスタックポインタ（ESP）が指すメモリ位置に格納され、実質的にスタックの新たな先頭位置となる。その後、スタックポインタはスタックの先頭位置の更新に合わせて調整（デクリメント）される。

```
push source
```

- pusha (すべてのワードをプッシュ):すべての 16 ビット汎用レジスタ (AX、BX、CX、DX、SI、DI、SP、BP) をスタックにプッシュ。
- pushad (すべてのダブルワードをプッシュ):すべての 32 ビット汎用レジスタ (EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP)をスタックにプッシュ。

pusha, pushad の命令に遭遇した場合（シェルコードの場合によくあること）、レジスタの状態を保存するために誰かがアセンブリ命令を手動で挿入した兆候であることが多い。

### POP

pop 命令はスタックの先頭から値を取り出し、それをデスティネーションオペランドに格納する。その結果、スタックポインタ（ESP）は、値のポップ後に行われた調整を反映してインクリメントされる。

```
pop destination
```

- popa（全ワードをポップ）：スタックの先頭から DI、SI、BP、BX、DX、CX、AX の順に値を汎用レジスタにポップ。SP または ESP は、 スタックの新しい先頭位置を反映するように調整される。

- popad（すべてのダブルワードをポップ）：スタックの先頭から EDI、 ESI 、EBP、EBX、EDX、ECX、EAX の順に値を汎用レジスタにポップ。SP または ESP は、スタックの新しい先頭位置を反映するように調整される。

### CALL

関数呼び出し操作を実行する。引数を渡す場合、call の前に push。

```
call location
```

実質的に二つの命令を実行する。

- 現在の命令ポインタ（EIP/RIP）をスタックにプッシュ
- EIP/RIP を関数先頭アドレスに変更
