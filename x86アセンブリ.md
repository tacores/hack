# x86 アセンブリ

https://tryhackme.com/room/x86assemblycrashcourse

https://tryhackme.com/room/win64assembly

## 基本

### オペランドの種類

- 即値 0x5f
- レジスタ eax
- メモリオペランド [eax]

### 汎用レジスタ

| レジスタ名 | 呼び方             | 説明                                                                 |
|------------|--------------------|----------------------------------------------------------------------|
| RAX        | アキュムレータレジスタ | 関数の戻り値を格納するためによく使用される                         |
| RBX        | ベースレジスタ       | メモリアクセスのベースポインタとして使用されるが、RBPとは異なる    |
| RDX        | データレジスタ       | 一部の命令でデータを保持するレジスタとして使用される              |
| RCX        | カウンタレジスタ     | ループ処理などのカウンターとして使用される                         |
| RSI        | ソースインデックス   | 文字列操作におけるソースポインタとして使用される                   |
| RDI        | 宛先インデックス     | 文字列操作における宛先ポインタとして使用される                     |
| RSP        | スタックポインタ     | スタックの先頭（現在のトップ）のアドレスを保持する                 |
| RBP        | ベースポインタ       | スタックフレームの基準となるアドレス（関数呼び出し時のベース）を保持する |

### ビット数

- RAX 64bit
- EAX 32bit
- AX 16bit
- AH 8bit
- AL 8bit

https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture

#### ゼロ拡張

EAXに値を入れると、RAXの残りの部分は0になる。しかしそれより小さいビット数で値を入れても、ゼロにならない。例えば、AXに値を入れても、RAXの残りの部分は変わらない。明示的にゼロ拡張するために`movzx`命令がある。

### その他

h は、hex の意。

```
mov eax,10h
```

## メモリレイアウト

- .data - Contains global and static data initialized to a non-zero value.
- .bss - Contains global and static data that is uninitialized or initialized to zero.
- .text - Contains the code of the program.

## 一般命令

### MOV（値を移動）

```
mov destination, source

mov eax, 0x5f
mov ebx, eax
mov eax, [0x5fc53e]
```

メモリーからメモリーへの MOV は不可。

### LEA（実効アドレスのロード）

オペランドには必ず角括弧が付く。  
算術結果をダイレクトにレジスタに代入したい場合によく使われる。

```
lea destination, source

lea eax, [ebp+4]
```

### NOP（何もしない）

マルウェア作成者がシェルコードへの実行をリダイレクトする際に使用される。実行がリダイレクトされる正確な場所は不明な場合が多いため、マルウェア作成者はシェルコードの実行が途中から開始されないように、多数の nop 命令を使用する。

```
nop
```

### SHIFT

ビットシフトした結果、1 があふれたらキャリーフラグ CF が 1 になる。

```
# right shift
shr destination, count

# left shift
shl destination, count
```

### ROTATE

左からあふれたビットが、右側に入ってくる

```
ror destination, count
rol destination, count
```

## 算術命令

### 加算、減算

```
add destination, value

sub destination, value
```

### 乗算、除算

乗算命令は、eax を乗算し、結果を 64 ビット値として edx:eax に格納する。

除算命令の場合は逆で、edx:eax 内の 64 ビット値を除算し、結果を eax に、余りを edx に格納する。

```
mul value

div value
```

### インクリメント、デクリメント

add, sub と異なり、CF を更新しない点は注意。

```
inc eax

dec eax
```

## 論理命令

### AND、OR、NOT、XOR

ビット単位の論理演算を実行

```
and al, 0x7c

or al, 0x7c

not al

xor al, 0x7c
```

## 条件文、分岐

### TEST、CMP

test 命令は、AND 演算を実行し、結果が 0 であれば、ゼロフラグ（ZF）を設定する。  
自身と比較することでオペランドの NULL チェックをするためによく使われる。

cmp 命令は sub 命令とほぼ同様に動作するが、オペランドは変更されず、ZF または CF が設定されるかに注目する。  
等しい場合は ZF、source の方が大きい場合は CF がセットされる。

```
test destination, source

cmp destination, source
```

### JUMP、条件 JUMP

```
jmp location
```

| 命令  | 説明                                                           |
| ----- | -------------------------------------------------------------- |
| `jz`  | ZF（ゼロフラグ）がセットされている場合にジャンプ（ZF = 1）     |
| `jnz` | ZF（ゼロフラグ）がセットされていない場合にジャンプ（ZF = 0）   |
| `je`  | 等しい場合にジャンプ。通常は `cmp` 命令の後に使われる          |
| `jne` | 等しくない場合にジャンプ。通常は `cmp` 命令の後に使われる      |
| `jg`  | 符号付き比較で、宛先オペランドがソースより大きい場合にジャンプ |
| `jl`  | 符号付き比較で、宛先オペランドがソースより小さい場合にジャンプ |
| `jge` | 符号付き比較で、宛先オペランドがソース以上の場合にジャンプ     |
| `jle` | 符号付き比較で、宛先オペランドがソース以下の場合にジャンプ     |
| `ja`  | 符号なし比較で、宛先オペランドがソースより大きい場合にジャンプ |
| `jb`  | 符号なし比較で、宛先オペランドがソースより小さい場合にジャンプ |
| `jae` | 符号なし比較で、宛先オペランドがソース以上の場合にジャンプ     |
| `jbe` | 符号なし比較で、宛先オペランドがソース以下の場合にジャンプ     |

## スタック命令

### PUSH

オペランドの値はスタックポインタ（ESP）が指すメモリ位置に格納され、実質的にスタックの新たな先頭位置となる。その後、スタックポインタはスタックの先頭位置の更新に合わせて調整（デクリメント）される。

```
push source
```

- pusha (すべてのワードをプッシュ):すべての 16 ビット汎用レジスタ (AX、BX、CX、DX、SI、DI、SP、BP) をスタックにプッシュ。
- pushad (すべてのダブルワードをプッシュ):すべての 32 ビット汎用レジスタ (EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP)をスタックにプッシュ。

pusha, pushad の命令に遭遇した場合（シェルコードの場合によくあること）、レジスタの状態を保存するために誰かがアセンブリ命令を手動で挿入した兆候であることが多い。

### POP

pop 命令はスタックの先頭から値を取り出し、それをデスティネーションオペランドに格納する。その結果、スタックポインタ（ESP）は、値のポップ後に行われた調整を反映してインクリメントされる。

```
pop destination
```

- popa（全ワードをポップ）：スタックの先頭から DI、SI、BP、BX、DX、CX、AX の順に値を汎用レジスタにポップ。SP または ESP は、 スタックの新しい先頭位置を反映するように調整される。

- popad（すべてのダブルワードをポップ）：スタックの先頭から EDI、 ESI 、EBP、EBX、EDX、ECX、EAX の順に値を汎用レジスタにポップ。SP または ESP は、スタックの新しい先頭位置を反映するように調整される。

### CALL

関数呼び出し操作を実行する。引数を渡す場合、call の前に push。

```
call location
```

実質的に二つの命令を実行する。

- 現在の命令ポインタ（EIP/RIP）をスタックにプッシュ
- EIP/RIP を関数先頭アドレスに変更

## 呼び出し規約

### x64 Linux

| 引数の番号 | 使用されるレジスタ | 備考                          |
|------------|---------------------|-------------------------------|
| 第1引数     | RDI                | 例: system("/bin/sh") の "/bin/sh" |
| 第2引数     | RSI                |                               |
| 第3引数     | RDX                |                               |
| 第4引数     | RCX                |                               |
| 第5引数     | R8                 |                               |
| 第6引数     | R9                 |                               |
| 7個目以降   | スタックにプッシュ     | RBPより高位に積まれる             |

### x64 Windows Fastcall

https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170&viewFallbackFrom=vs-2019

https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170&viewFallbackFrom=vs-2019

| 引数の番号     | 使用されるレジスタ                   | 備考                                |
| --------- | --------------------------- | --------------------------------- |
| 第1引数      | RCX                         |                                   |
| 第2引数      | RDX                         |                                   |
| 第3引数      | R8                          |                                   |
| 第4引数      | R9                          |                                   |
| 第5引数以降    | スタック（右から左に渡す）               | 16バイト境界に揃えられ、shadow spaceを超えて積まれる |
| 戻り値       | RAX                         |                                   |
| 呼び出し側が保存  | RAX, RCX, RDX, R8–R11       | 呼び出し元が保存不要＝破壊される可能性あり             |
| 呼び出され側が保存 | RBX, RBP, RDI, RSI, R12–R15 | 必要なら保存・復元が必要                      |
| 特記事項      | Shadow Space (32バイト)        | 呼び出し時、呼び出し側が確保（RAX～R9用）           |

- 最初の4つのパラメータは、レジスタを介して左から右へ渡されます。整数、ポインタ、文字などの浮動小数点値以外のパラメータは、RCX、RDX、R8、R9（この順序で）を介して渡されます。浮動小数点パラメータは、XMM0、XMM1、XMM2、XMM3（この順序で）を介して渡されます。
- 浮動小数点値と整数値が混在する場合でも、それぞれの位置に対応するレジスタを介して渡されます。例えば、func(1, 3.14, 6, 6.28)最初のパラメータはRCX、2番目のパラメータはXMM1、3番目のパラメータはR8、最後のパラメータはXMM3を介して渡されます。
- 渡されるパラメータが大きすぎてレジスタに収まらない場合は、参照渡し（メモリ内のデータへのポインタ）されます。パラメータは、対応する任意のサイズのレジスタを介して渡すことができます。例えば、RCX、ECX、CX、CH、CLはすべて最初のパラメータとして使用できます。その他のパラメータは、右から左の順にスタックにプッシュされます。
- たとえパラメータが全く存在しない場合でも、スタックには常に4つのパラメータ用の領域が割り当てられます。この領域はコンパイラが使用できるため、完全に無駄になるわけではありません。多くの場合、コンパイラはこの領域を使用します。通常、デバッグビルドの場合、コンパイラはこの領域にパラメータのコピーを配置します。リリースビルドの場合、コンパイラはこの領域を一時変数またはローカル変数の格納場所として使用します。
- メンバ関数の場合、thisが常に第一引数（RCX）になる。
- 呼び出し元は、呼び出し先のパラメータ用の領域を割り当てる責任があります。パラメータが渡されない場合でも、呼び出し元は常に4つのパラメータ用の領域を割り当てる必要があります。
- レジスタ RAX、RCX、RDX、R8、R9、R10、R11、および XMM0-XMM5 は揮発性であると見なされ、関数呼び出し時に破棄されるものと見なす必要があります。
- レジスタ RBX、RBP、RDI、RSI、RSP、R12、R13、R14、R15、および XMM6-XMM15 は不揮発性であると見なされ、それらを使用する関数によって保存および復元される必要があります。
- 5個以降のパラメータは右から左にPushされる。

